## I-DLV executable and options
solver.name=idlv
# Windows executable
# solver.path=executables/idlv_1.1.6_windows_x86-64.exe
# Linux executable
solver.path=executables/idlv_1.1.6_linux_x86-64
solver.options.grounding=--t --no-facts --check-edb-duplication
solver.options.query=--query

# ## DLV executable and options
# solver.name=dlv
# # Windows executable
# solver.path=executables/dlv.mingw.exe
# # Linux executable
# # solver.path=executables/dlv.x86-64-linux-elf-static.bin
# solver.options.grounding=-nofacts
# solver.options.query=-silent -FC

# ## DLV2 executable and options
# solver.name=dlv2
# # Windows executable
# solver.path=executables/dlv2-windows.exe
# # Linux executable
# # solver.path=executables/dlv2-linux
# solver.options.grounding=--t --no-facts --check-edb-duplication
# solver.options.query=--silent --query --mode=idlv

## Execution options
solver.output.to_file=false
solver.full_grounding=true
saturation_only=true
# select the algorithm used for the TGD saturation
# It can be: gsat (default), skolemized_sat, simple_sat
saturation_alg=gsat
debug=false

# timeout in seconds
# timeout=30

# are negative constraints included
negative_constraint=true

# change the way variables are renamed in VNF
sorted_vnf=true

# - min_predicate
# - min_atom
# - tree_predicate
# - identity
subsumption_method=tree_predicate

# Simple sat filters the full TGDs it generates 
# such that their body always contains at least a predicate 
# appearing in a non full TGDs head
simple_sat_predicate_filter=true

# ========= Evolve-Based algoritm optimizations ========= 

# In evolved based algorithms, the new TGDs (right and left) are stored 
# in sets :
# - SET, for hashset
# - ORDERED_BY_ATOMS_NB, such that the TGDs with smallest body and largest head come first
# - STACK
optimization.new_tgd_structure = SET

# In evolved based algorithms, the new TGDs can be subsumed by the TGDs outputed by an 
# evolve application on this new TGD and others TGDs. This parameter allows stop to apply evolve
# using this new TGDs, when it is subsumed by one of the outputed TGDs.
optimization.stop_evolving_if_subsumed = true

# True, if the evolving tgd are sorted 
optimization.evolving_tgd_ordering = true

# In evolve-based saturation, if true, the new derived non full TGDs will be discarded,
# if their head do not contains at least a new atom (w.r.t. the evolved non full TGD ),
# whose predicate appears in at least one other TGD body.
optimization.discard_useless_tgd = true

optimization.maxPredicate = 450